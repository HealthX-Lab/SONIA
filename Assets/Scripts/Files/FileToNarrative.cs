using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Class to extract a Narrative and subsequent NarrativeNodes from a .txt file
/// </summary>
public class FileToNarrative
{
    /// <summary>
    /// The Narrative generated by the file
    /// </summary>
    public Narrative Narrative { get; private set; }
    
    /// <summary>
    /// The full (unordered) list of NarrativeNodes in the Narrative
    /// </summary>
    public List<NarrativeNode> Nodes { get; private set; }
    
    /// <summary>
    /// Method to loop through the file, creating new NarrativeNodes and a new Narrative
    /// </summary>
    /// <param name="file">The .txt file from which the Narrative will be loaded</param>
    public void Load(TextAsset file)
    {
        string[] split = SplitAndTrim(file.text, '\n');

        Nodes = new List<NarrativeNode>();

        // Starting after the Narrative description and starting node lines
        for (int i = 2; i < split.Length; i++)
        {
            // When a new NarrativeNode section is found
            if (split[i].Equals("[NODE]"))
            {
                NarrativeNode tempNode = new NarrativeNode(split[i+1], split[i+2]);
                tempNode.ObjectName = split[i+3];
                
                // Initializing the required lists that will be added to in the future
                tempNode.Next = new List<NarrativeNode>();
                tempNode.NextNames = new List<string>();
                tempNode.EdgeDescriptions = new List<string>();
                    
                int offset = i + 4; // Jumping to the next nodes part of the NarrativeNode section
    
                // Confirming that we're in the right place
                if (split[offset].Equals("[NEXT]"))
                {
                    // Making sure that the next nodes part isn't empty
                    if (!split[offset + 1].Equals("[PREVIOUS]"))
                    {
                        offset++;
    
                        // Looping through and adding the next nodes' information until the previous node part is found
                        while (!split[offset].Equals("[PREVIOUS]"))
                        {
                            tempNode.NextNames.Add(split[offset]);
                            tempNode.EdgeDescriptions.Add(split[offset+1]);
    
                            offset += 2;
                        }
                    }
                    else
                    {
                        offset++;
                    }
    
                    // Confirming that we're in the right place
                    if (split[offset].Equals("[PREVIOUS]"))
                    {
                        // Making sure that the previous nodes part isn't empty
                        if (offset + 2 < split.Length && !split[offset+1].Equals("") && !split[offset+1].Equals("[NODE]"))
                        {
                            offset++;
    
                            // Adding the previous node's inforation
                            tempNode.PreviousName = split[offset];
                            tempNode.PreviousEdgeDescription = split[offset+1];
    
                            i = offset + 1; // Moving the loop index ahead as so to skip over the now used node section
                        }
                    }
                }
                    
                Nodes.Add(tempNode); // Adding the new node after it has been set up
            }
        }

        // After creating the nodes, they are linked up properly (this prevents trying to link nodes up when they haven't even been created yet)
        foreach (NarrativeNode j in Nodes)
        {
            foreach (string k in j.NextNames)
            {
                j.Next.Add(FindNodeWithName(k, Nodes));
            }

            j.Previous = FindNodeWithName(j.PreviousName, Nodes);
        }
        
        // Creating the new Narrative, after accessing the start node
        Narrative temp = new Narrative(
            file.name,
            split[0],
            FindNodeWithName(split[1], Nodes)
        );

        Narrative = temp;
    }

    /// <summary>
    /// Splits a string into an array based on a given delimiter, then trims each value
    /// </summary>
    /// <param name="text">The string to be split</param>
    /// <param name="delim">The delimiter to partition the string</param>
    /// <returns>A newly split and individually trimmed array</returns>
    string[] SplitAndTrim(string text, char delim)
    {
        string[] temp = text.Split(delim);

        for (int i = 0; i < temp.Length;i++)
        {
            temp[i] = temp[i].Trim();
        }

        return temp;
    }

    /// <summary>
    /// Loops through a list of NarrativeNodes, returning the one that matches the given name
    /// </summary>
    /// <param name="name">The name of the node being searched for</param>
    /// <param name="nodes">The list of node in which to search</param>
    /// <returns>The NarrativeNode with the given name (null if not found)</returns>
    NarrativeNode FindNodeWithName(string name, List<NarrativeNode> nodes)
    {
        foreach (NarrativeNode i in nodes)
        {
            if (i.Name.Equals(name))
            {
                return i;
            }
        }

        return null;
    }
}